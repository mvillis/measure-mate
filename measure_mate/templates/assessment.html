{% extends "base.html" %}
{% load staticfiles %}

{% block title %}Measure Mate{% endblock %}
{% block head %}
  <script src="{% static "components/lodash/dist/lodash.min.js" %}"></script>
  <script src="{% static "components/underscore/underscore-min.js" %}"></script>
{% endblock %}
{% block body %}
<div id="content" class="container"></div>
<script type="text/babel">

  var Alert = ReactBootstrap.Alert;
  var PageHeader = ReactBootstrap.PageHeader;
  var ListGroup = ReactBootstrap.ListGroup;
  var ListGroupItem = ReactBootstrap.ListGroupItem;
  var Tabs = ReactBootstrap.Tabs;
  var Tab = ReactBootstrap.Tab;
  var Panel = ReactBootstrap.Panel;
  var Input = ReactBootstrap.Input;
  var Tooltip = ReactBootstrap.Tooltip;
  var OverlayTrigger = ReactBootstrap.OverlayTrigger;
  var Pager = ReactBootstrap.Pager;
  var PageItem = ReactBootstrap.PageItem;
  var Glyphicon = ReactBootstrap.Glyphicon;
  var Button = ReactBootstrap.Button;
  var Table = ReactBootstrap.Table;
  var Popover = ReactBootstrap.Popover;

  var AttributeList = React.createClass({
    propTypes: {
      assess_id: React.PropTypes.string,
    },
    getInitialState: function() {
      return {
        active_tab: 1,
        active_attribute: null,
        measurements: null,
        template: null,
        assessment: null,
        next_hide: false,
        previous_hide: false,
        initial_load: false,
        measure_sync_activity: false,
        observations: {},
        dirty_observation: {}
      };
    },
    componentWillMount: function(){
      this.dataSource("/api/assessments/" + this.props.assess_id + "/", this.assessment_callback);
    },
    measurement_callback: function (data) {
      this.setState( {
        measurements: data,
        initial_load: true
      });
      this.handleSelect(1);
    },
    template_callback: function (data) {
      this.setState( {
        template: data
      }, this.dataSource("/api/measurements/" + "?assessment__id=" + this.props.assess_id, this.measurement_callback)
      );
    },
    assessment_callback: function (data) {
      this.setState( {
        assessment: data
      }, this.dataSource("/api/templates/" + data.template.id + "/", this.template_callback)
      );
    },
    handleSubmitFailure: function(xhr, ajaxOptions, thrownError) {
        console.error("There was a failure");
    },
    dataSource: function(url, callback){
      $.ajax({
        type: "get",
        dataType: 'json',
        url: url,
        success: callback,
        error: this.handleSubmitFailure,
      });
    },
    measurement_update_callback: function (data) {
      var existing_measurement_index = _.findIndex(this.state.measurements, function(measurement)
      {
        return measurement.id == data.id;
      });
      var updated_dirty_observation = this.state.dirty_observation;
      updated_dirty_observation[this.state.active_tab] = false
      if (existing_measurement_index != -1) {
        var updated_measurements = this.state.measurements.slice();
        updated_measurements[existing_measurement_index] = data;
        this.setState({
          measurements: updated_measurements,
          measure_sync_activity: false,
          dirty_observation: updated_dirty_observation
        });
      }
      else {
        var new_measurements = this.state.measurements.concat([data]);
        this.setState({
          measurements: new_measurements,
          measure_sync_activity: false,
          dirty_observation: updated_dirty_observation
        });
      };
    },
    syncMeasurement: function(postData) {
      var create_new_measure = ((postData.id) ? false : true);
      if (this.state.observations[this.state.active_tab]) {
        postData["observations"] = this.state.observations[this.state.active_tab]
      } else {
        var match_measure = _.find(this.state.measurements, function(measurement)
          {
            return measurement.id == postData.id;
          });
        (match_measure) ? postData["observations"] = match_measure.observations : postData["observations"] = "";
      }
      this.setState({ measure_sync_activity: true });
      console.log('Should a new measurement be created? ' + create_new_measure);
      $.ajax({
        type: ((create_new_measure) ? "POST" : "PUT"),
        contentType: "application/json; charset=utf-8",
        url: ((create_new_measure) ? "/api/measurements/" : ("/api/measurements/" + postData.id + '/')),
        data: JSON.stringify(postData),
        dataType: 'json',
        success: this.measurement_update_callback,
        error: this.handleSubmitFailure,
      });
    },
    onObservationChange: function(text, active_tab) {
      var observations = this.state.observations;
      observations[active_tab] = text;
      var updated_dirty_observation = this.state.dirty_observation;
      updated_dirty_observation[this.state.active_tab] = true
      this.setState({observations: observations, dirty_observation: updated_dirty_observation});
    },
    handleNext: function () {
      if (this.state.active_tab < this.state.template.attributes.length && !this.state.next_hide) {
        var new_tab = this.state.active_tab + 1;
        this.scrollToTop('#att-list');
        this.setState({active_tab: new_tab});
        this.handleTabChange(new_tab);
      };
    },
    handlePrevious: function () {
      if (this.state.active_tab !=1 && !this.state.previous_hide) {
        var new_tab = this.state.active_tab - 1;
        this.scrollToTop('#att-list');
        this.setState({active_tab: new_tab});
        this.handleTabChange(new_tab);
      }
    },
    handleSelect: function (key) {
      this.scrollToTop('#att-list');
      this.setState({active_tab: key});
      this.handleTabChange(key);
    },
    handleTabChange: function (current_tab) {
      if (current_tab == 1) {
        this.setState({previous_hide: true});
      } else {
        this.setState({previous_hide: false});
      }
      if (current_tab >= this.state.template.attributes.length) {
        this.setState({next_hide: true});
      } else {
        this.setState({next_hide:false});
      }
    },
    scrollToTop: function (att_list) {
      var $target = $(att_list);

      $('html, body').stop().animate({
          'scrollTop': $target.offset().top
      }, 900, 'swing', function () {
          // window.location.hash = $target;
      });
    },
    getAttributeForRating: function(query_rating) {
      var matching_attribute = null
      for (var i = 0; i<this.state.template.attributes.length; i++) {
        for (var ii = 0; ii<this.state.template.attributes[i].ratings.length; ii++) {
          if (query_rating == this.state.template.attributes[i].ratings[ii].id) {
            matching_attribute = this.state.template.attributes[i].id;
            break;
          }
        }
      }
      return matching_attribute;
    },
    getMeasurementForAttribute: function(attribute) {
      if (this.state.measurements != null) {
        for (var i=0; i < this.state.measurements.length; i++) {
          if (attribute.id == this.getAttributeForRating(this.state.measurements[i].rating)) {
            return this.state.measurements[i];
            break;
          }
        };
      } else {
        return null;
      }
    },
    render: function() {
      if (this.state.template) {
        var attributeNodes = this.state.template.attributes.map(function (attribute, i) {
          var measurement = this.getMeasurementForAttribute(attribute);
          return (
            <Tab eventKey={i+1} key={attribute.id} id={i+1} title={<div><span className="glyphicon glyphicon-chevron-right"></span> <span>{attribute.name}</span></div>}>
            <Panel header={attribute.name} bsStyle="primary">
              <Alert bsStyle="warning">
                {attribute.desc}
              </Alert>
              <ObserveInput eventKey={i+1} dirty_observation={this.state.dirty_observation} active_tab={this.state.active_tab} measurement={measurement} syncMeasurement={this.syncMeasurement} onObservationChange={this.onObservationChange}/>
              <Loader loaded={!this.state.measure_sync_activity}>
              </Loader>
              <ListGroup fill>
                <RatingList dirty_observation={this.state.dirty_observation} key={attribute.id} measurement={measurement} attribute={attribute} assess_id={this.props.assess_id} syncMeasurement={this.syncMeasurement}/>
              </ListGroup>
            </Panel>
            </Tab>
          );
        }.bind(this));
      }
      return (
        <div id="att-list">
          <Loader loaded={this.state.initial_load}>
            <PageHeader>
              {!!this.state.assessment == true ? this.state.assessment.template.name : ""} <small> {!!this.state.assessment ? this.state.assessment.template.short_desc : ""}</small>
            </PageHeader>
            <Tabs position="right" activeKey={this.state.active_tab} onSelect={this.handleSelect} tabWidth={3}>
              {attributeNodes}
              <Pager>
                <PageItem disabled={this.state.previous_hide} onClick={this.handlePrevious}>&larr; Previous</PageItem>
                {' '}
                <PageItem disabled={this.state.next_hide} onClick={this.handleNext}>Next &rarr;</PageItem>
              </Pager>
            </Tabs>
          </Loader>
        </div>
      );
    }
  });

  var ObserveInput = React.createClass({
      propTypes: {
        measurement: React.PropTypes.object,
        syncMeasurement: React.PropTypes.func.isRequired,
        onObservationChange: React.PropTypes.func.isRequired,
        dirty_observation: React.PropTypes.object,
        active_tab: React.PropTypes.number,
        eventKey: React.PropTypes.number
      },
      getInitialState: function () {
          return {
              save_btn_disabled: true,
              observations: ""
          };
      },
      componentWillMount: function() {
         this.handleObserveDebounced = _.debounce(function () {
           this.props.onObservationChange.apply(this, [this.state.observations, this.props.active_tab]);
         }, 1000);
      },
      onChange: function (event) {
        this.setState({ observations: event.target.value });
        this.handleObserveDebounced();
      },
      handleSave: function() {
        if (this.state.save_btn_disabled == false) {
          var postData = {
            id: this.props.measurement.id,
            assessment: this.props.measurement.assessment,
            rating: this.props.measurement.rating,
            target_rating: this.props.measurement.target_rating
          };
          this.props.syncMeasurement(postData);
        }
      },
      componentWillReceiveProps: function (nextProps) {
        if (nextProps.measurement && !this.state.observations) {
          this.setState({observations: nextProps.measurement.observations})
        }

        if (nextProps.measurement) { this.setState({save_btn_disabled: false})};
      },
      shouldComponentUpdate: function (nextProps, nextState) {
        if (nextProps.active_tab === this.props.eventKey) {
          return true
        }
        return false;
      },
      render: function () {
        var syncStatus = function () {
          if (this.props.dirty_observation[this.props.active_tab] == false && this.props.measurement) {
            return (<span><span>   </span><Glyphicon glyph="glyphicon glyphicon-saved" /></span>);
          } else if (this.props.dirty_observation[this.props.active_tab] == true && !this.props.measurement) {
              return (<span className="text-info"><span>  </span><Glyphicon glyph="glyphicon glyphicon-info-sign" /> Select a rating below to save this comment and complete the form.</span>);
          } else {
            return (<span></span>);
          };
        }.bind(this);
        return (
          <div>
            <Input type="textarea" rows="3" label="Observations" placeholder="Discuss your current practices and capture some notes."
                   ref="observeInput"
                   value={this.state.observations}
                   onChange={this.onChange} Input/>
                     <Button ref="obsSaveBtn" disabled={this.state.save_btn_disabled} bsStyle="primary" bsSize="xsmall" onClick={this.handleSave}>Save</Button>
                     {syncStatus()}
           </div>
        );
      }
  });

  var RatingList = React.createClass({
    propTypes: {
      key: React.PropTypes.number,
      measurement: React.PropTypes.object,
      assess_id: React.PropTypes.string.isRequired,
      syncMeasurement: React.PropTypes.func.isRequired,
      attribute: React.PropTypes.object,
    },
    componentWillMount() {
      this.props.syncMeasurement = _.debounce(this.props.syncMeasurement, 250);
    },
    saveMeasurement: function (value) {
      var existing_measurement = (this.props.measurement) ? true : false;
      var postData = {
        id: (this.props.measurement) ? this.props.measurement.id : "",
        assessment: this.props.assess_id,
        rating: (value['rating']) ? value['rating'] : this.props.measurement.rating,
        target_rating: (value['target']) ? value['target'] : ((existing_measurement && this.props.measurement.target_rating) ? this.props.measurement.target_rating : ""),
      };
      this.props.syncMeasurement(postData);
    },
    render: function() {
      var ratingNodes = this.props.attribute.ratings.map(function (rating) {
          var rating_active = (this.props.measurement && this.props.measurement.rating) ? (this.props.measurement.rating == rating.id) : false;
          var target_active = (this.props.measurement && this.props.measurement.target_rating) ? (this.props.measurement.target_rating == rating.id) : false;
          var target_bs_style = target_active ? "success" : "default";
          var desc_class = "rating-" + rating.name + (rating.desc_class ? " " + rating.desc_class : "")
          var header = function () {
            if ((this.props.measurement && this.props.measurement.rating)) {
              return (
                <div>
                  <h4 className="inline clickable" onClick={this.saveMeasurement.bind(this, {rating: rating.id})}>{rating.name}</h4>
                  <Button ref='currentBtn'
                      onClick={this.saveMeasurement.bind(this, {target: rating.id})}
                      bsStyle={target_bs_style} className="target-btn"
                      active={target_active}
                      bsSize='xsmall'>
                      Target
                  </Button>
                  <OverlayTrigger trigger="click" placement="left" rootClose overlay={<Popover id={rating.id}>You have decided your current rating. Set your future goal by selecting a target button.</Popover>}>
                    <Glyphicon className="target-help clickable" glyph="glyphicon glyphicon-question-sign" />
                  </OverlayTrigger>
                </div>
              );
            } else {
              return (
                <div>
                  <h4 className="inline clickable" onClick={this.saveMeasurement.bind(this, {rating: rating.id})}>{rating.name}</h4>
                </div>
              )
            }
          }.bind(this)();
          return (
            <ListGroupItem active={rating_active} id={rating.id} key={rating.id} header={header} className={desc_class}>
              <div className="clickable" onClick={this.saveMeasurement.bind(this, {rating: rating.id})}>
                {rating.desc}
              </div>
            </ListGroupItem>
          );
      }.bind(this));
      var desc_class = this.props.desc_class || ""
      return (<div>
            {ratingNodes}
            </div>
      );
    }
  });

  ReactDOM.render(
  <AttributeList assess_id="{{id}}"/>,
  document.getElementById('content')
  );
</script>
{% endblock %}
