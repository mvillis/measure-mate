{% extends "base.html" %}
{% load staticfiles %}

{% block title %}Measure Mate{% endblock %}
{% block head %}
  <script src="{% static "components/lodash/dist/lodash.min.js" %}"></script>
{% endblock %}
{% block body %}
<div id="content" class="container"></div>
<script type="text/babel">

  var Alert = ReactBootstrap.Alert;
  var PageHeader = ReactBootstrap.PageHeader;
  var ListGroup = ReactBootstrap.ListGroup;
  var ListGroupItem = ReactBootstrap.ListGroupItem;
  var Tabs = ReactBootstrap.Tabs;
  var Tab = ReactBootstrap.Tab;
  var Panel = ReactBootstrap.Panel;
  var Input = ReactBootstrap.Input;
  var Tooltip = ReactBootstrap.Tooltip;
  var OverlayTrigger = ReactBootstrap.OverlayTrigger;
  var Pager = ReactBootstrap.Pager;
  var PageItem = ReactBootstrap.PageItem;
  var Glyphicon = ReactBootstrap.Glyphicon;
  var Button = ReactBootstrap.Button;
  var Table = ReactBootstrap.Table;
  var Popover = ReactBootstrap.Popover;

  var AttributeList = React.createClass({
    propTypes: {
      assess_id: React.PropTypes.string,
    },
    getInitialState: function() {
      return {
        active_attribute: 1,
        rating_selected: false,
        measurements: null,
        template: null,
        assessment: null,
        next_hide: false,
        previous_hide: false,
        initial_load: false
      };
    },
    componentWillMount: function(){
      this.dataSource("/api/assessments/" + this.props.assess_id + "/", this.assessment_callback);
    },
    measurement_callback: function (data) {
      this.setState( {
        measurements: data,
        initial_load: true
      });
      this.handleSelect(1);
    },
    template_callback: function (data) {
      this.setState( {
        template: data
      }, this.dataSource("/api/measurements/" + "?assessment__id=" + this.props.assess_id, this.measurement_callback)
      );
    },
    assessment_callback: function (data) {
      this.setState( {
        assessment: data
      }, this.dataSource("/api/templates/" + data.template.id + "/", this.template_callback)
      );
    },
    handleSubmitFailure: function(xhr, ajaxOptions, thrownError) {
        console.error("There was a failure");
    },
    dataSource: function(url, callback){
      $.ajax({
        type: "get",
        dataType: 'json',
        url: url,
        success: callback,
        error: this.handleSubmitFailure,
      });
    },
    handleNext: function () {
      if (this.state.active_attribute < this.state.template.attributes.length && !this.state.next_hide) {
        var new_tab = this.state.active_attribute + 1;
        this.scrollToTop('#att-list');
        this.setState({active_attribute: new_tab});
        this.handleTabChange(new_tab);
      };
    },
    handlePrevious: function () {
      if (this.state.active_attribute !=1 && !this.state.previous_hide) {
        var new_tab = this.state.active_attribute - 1;
        this.scrollToTop('#att-list');
        this.setState({active_attribute: new_tab});
        this.handleTabChange(new_tab);
      }
    },
    handleSelect: function (key) {
      this.scrollToTop('#att-list');
      this.setState({active_attribute: key});
      this.handleTabChange(key);
    },
    handleTabChange: function (current_tab) {
      if (current_tab == 1) {
        this.setState({previous_hide: true});
      } else {
        this.setState({previous_hide: false});
      }
      if (current_tab >= this.state.template.attributes.length) {
        this.setState({next_hide: true});
      } else {
        this.setState({next_hide:false});
      }
    },
    scrollToTop: function (att_list) {
      var $target = $(att_list);

      $('html, body').stop().animate({
          'scrollTop': $target.offset().top
      }, 900, 'swing', function () {
          // window.location.hash = $target;
      });
    },
    getMeasurementForAttribute(attribute) {
      if (this.state.measurements != null) {
        for (var i=0; i < this.state.measurements.length; i++) {
          if (attribute.id == this.state.measurements[i].rating.attribute) {
            return this.state.measurements[i];
            break;
          }
        };
      } else {
        return null;
      }
    },
    render: function() {
      if (this.state.template) {
        var attributeNodes = this.state.template.attributes.map(function (attribute, i) {
          var measurement = this.getMeasurementForAttribute(attribute);
          return (
            <Tab eventKey={i+1} key={attribute.id} id={i+1} title={<div><span className="glyphicon glyphicon-chevron-right"></span> <span>{attribute.name}</span></div>}>
              <RatingList key={attribute.id} measurement={measurement} attribute_id={attribute.id} assess_id={this.props.assess_id} name={attribute.name} desc={attribute.desc} desc_class={attribute.desc_class} data={attribute.ratings}/>
            </Tab>
          );
        }.bind(this));
      }
      return (
        <div id="att-list">
          <Loader loaded={this.state.initial_load}>
            <PageHeader>
              {!!this.state.assessment == true ? this.state.assessment.template.name : ""} <small> {!!this.state.assessment ? this.state.assessment.template.short_desc : ""}</small>
            </PageHeader>
            <Tabs position="right" activeKey={this.state.active_attribute} onSelect={this.handleSelect} tabWidth={3}>
              {attributeNodes}
              <Pager>
                <PageItem disabled={this.state.previous_hide} onClick={this.handlePrevious}>&larr; Previous</PageItem>
                {' '}
                <PageItem disabled={this.state.next_hide} onClick={this.handleNext}>Next &rarr;</PageItem>
              </Pager>
            </Tabs>
          </Loader>
        </div>
      );
    }
  });

  var ObserveInput = React.createClass({
      propTypes: {
        observation_synced: React.PropTypes.bool,
        selected_rating: React.PropTypes.number,
        observations: React.PropTypes.string.isRequired,
        observationSyncUpdate: React.PropTypes.func.isRequired,
        updateObserve: React.PropTypes.func.isRequired,
        saveMeasurement: React.PropTypes.func.isRequired,
        syncMeasurement: React.PropTypes.func.isRequired,
      },
      getInitialState: function () {
          return {
              save_btn_disabled: true
          };
      },
      componentWillReceiveProps: function(newProps) {
        if (this.state.observations == null) {
          this.setState(
            {
              observations: newProps.observations,
              observation_synced: newProps.observation_synced,
              selected_rating: newProps.selected_rating
            });
        } else {
          this.setState(
            {
              observation_synced: newProps.observation_synced,
              selected_rating: newProps.selected_rating
            }
          )
        }
        if (!!newProps.observation_synced == true) {
          this.setState(
            {
              save_btn_disabled: true
            }
          )
        }
      },
      componentWillMount: function() {
        //  this.handleObserveDebounced = _.debounce(function () {
        //    console.log("Inside debounce: " + this.state.observations);
        //    this.props.handleObserve.apply(this, [this.state.observations]);
        //  }, 5000);
      },
      onChange: function (event) {
        var new_observations = event.target.value;
        if (this.state.selected_rating) {
          this.setState(
            {
              observations: new_observations,
              observation_synced: false,
              save_btn_disabled: false
            });
        } else {
          this.setState(
            {
              observations: new_observations,
              observation_synced: false,
              save_btn_disabled: true
            });
        }
        this.props.observationSyncUpdate(false);
        this.props.updateObserve(event.target.value);
        // this.handleObserveDebounced();
      },
      handleSave: function() {
        if (this.state.save_btn_disabled == false) {
          this.props.saveMeasurement();
        }
      },
      render: function () {
        var syncStatus = function () {
          if (this.state.observation_synced == true) {
            return (<span><span>  </span><Glyphicon glyph="glyphicon glyphicon-saved" /> Saved</span>);
          } else if (this.state.observation_synced == false) {
            if (!!this.state.selected_rating == false) {
              return (<span className="text-info"><span>  </span><Glyphicon glyph="glyphicon glyphicon-info-sign" /> Select a rating below to save this comment and complete the form.</span>);
            }
          } else {
            return (<span></span>);
          };
        }.bind(this);
        return (
          <div>
            <Input type="textarea" rows="3" label="Observations" placeholder="Discuss your current practices and capture some notes."
                   ref="observeInput"
                   value={this.state.observations}
                   onChange={this.onChange} Input/>
                     <Button ref="obsSaveBtn" disabled={this.state.save_btn_disabled} bsStyle="primary" bsSize="xsmall" onClick={this.handleSave}>Save</Button>
                     {syncStatus()}
           </div>
        );
      }
  });

  var RatingList = React.createClass({
    propTypes: {
      key: React.PropTypes.number,
      measurement: React.PropTypes.object,
      attribute_id: React.PropTypes.number.isRequired,
      assess_id: React.PropTypes.string.isRequired,
      name: React.PropTypes.string.isRequired,
      desc: React.PropTypes.string.isRequired,
      desc_class: React.PropTypes.string.isRequired,
      data: React.PropTypes.array.isRequired,
    },
    componentWillMount() {
      this.syncMeasurement = _.debounce(this.syncMeasurement, 250);
    },
    getInitialState: function() {
      if (this.props.measurement != null) {
        var selected_target = (this.props.measurement.target_rating) ? this.props.measurement.target_rating.id : null;
        return {
          measurement_id: this.props.measurement.id,
          selected_rating: this.props.measurement.rating.id,
          selected_target: selected_target,
          observations: this.props.measurement.observations,
          observation_synced: null,
          saved_measurement: true
        };
      } else {
        return {
          measurement_id: null,
          selected_rating: null,
          selected_target: null,
          observations: "",
          observation_synced: null,
          saved_measurement: true
        };
      }
    },
    componentWillReceiveProps: function(newProps) {
      if (newProps.measurement && newProps.measurement.id != this.measurement_id) {
        var selected_target = (newProps.measurement.target_rating) ? newProps.measurement.target_rating.id : null;
        this.setState(
          {
            measurement_id: newProps.measurement.id,
            selected_rating: newProps.measurement.rating.id,
            selected_target: selected_target,
            observations: newProps.measurement.observations,
          });
      }
    },
    syncMeasurement: function(postData) {
      var create_new_measure = ((this.state.measurement_id == null) ? true : false);
      console.log('Should a new measurement be created? ' + create_new_measure);
      $.ajax({
        type: ((create_new_measure) ? "POST" : "PUT"),
        contentType: "application/json; charset=utf-8",
        url: ((create_new_measure) ? "/api/measurements/" : ("/api/measurements/" + this.state.measurement_id + '/')),
        data: JSON.stringify(postData),
        dataType: 'json',
        success: this.handleSubmitSuccess,
        error: this.handleSubmitFailure,
      });
    },
    observationSyncUpdate: function (synced) {
      this.setState({observation_synced: synced});
    },
    updateObserve: function(text) {
      this.setState({observations: text});
    },
    saveMeasurement: function () {
      var postData = {
        id: this.state.measurement_id,
        assessment: this.props.assess_id,
        rating: this.state.selected_rating,
        target_rating: this.state.selected_target,
        observations: this.state.observations
      };
      this.setState(
        {
          saved_measurement: false
        });
      this.syncMeasurement(postData);
    },
    handleClick: function(data) {
      this.setState(
        {
          selected_rating: data,
        }, this.saveMeasurement);
    },
    handleTargetClick: function(data) {
      this.setState(
        {
          selected_target: data
        },
        this.saveMeasurement
      )
    },
    handleSubmitSuccess: function(data) {
      this.setState({
        measurement_id: data.id,
        observation_synced: true,
        saved_measurement: true
      });
    },
    handleSubmitFailure: function(xhr, ajaxOptions, thrownError) {
        console.error("There was a failure");
    },
    render: function() {
      var ratingNodes = this.props.data.map(function (rating) {
          var rating_active = (this.state.selected_rating == rating.id)
          var target_active = (this.state.selected_target == rating.id)
          var target_bs_style = target_active ? "success" : "default";
          var desc_class = "rating-" + rating.name + (rating.desc_class ? " " + rating.desc_class : "")
          var header = function () {
            if (!!this.state.selected_rating) {
              return (
                <div>
                  <h4 className="inline clickable">{rating.name}</h4>
                  <Button ref='currentBtn'
                      onClick={this.handleTargetClick.bind(this, rating.id)}
                      bsStyle={target_bs_style} className="target-btn"
                      active={target_active}
                      bsSize='xsmall'>
                      Target
                  </Button>
                  <OverlayTrigger trigger="click" placement="left" rootClose overlay={<Popover id={rating.id}>You have decided your current rating. Set your future goal by selecting a target button.</Popover>}>
                    <Glyphicon className="target-help clickable" glyph="glyphicon glyphicon-question-sign" />
                  </OverlayTrigger>
                </div>
              );
            } else {
              return (
                <div>
                  <h4 className="inline clickable">{rating.name}</h4>
                </div>
              )
            }
          }.bind(this)();
          return (
            <ListGroupItem active={rating_active} id={rating.id} key={rating.id} header={header} className={desc_class}>
              <div className="clickable" onClick={this.handleClick.bind(this, rating.id)}>
                {rating.desc}
              </div>
            </ListGroupItem>
          );
      }.bind(this));
      var desc_class = this.props.desc_class || ""
      return (
        <Panel header={this.props.name} bsStyle="primary">
          <Alert className={desc_class} bsStyle="warning">
            {this.props.desc}
          </Alert>
          <ObserveInput observation_synced={this.state.observation_synced} selected_rating={this.state.selected_rating} observations={this.state.observations} observationSyncUpdate={this.observationSyncUpdate}
                     updateObserve={this.updateObserve} saveMeasurement={this.saveMeasurement} syncMeasurement={this.syncMeasurement}/>
          <Loader loaded={this.state.saved_measurement}>
          </Loader>
          <ListGroup fill>
            {ratingNodes}
          </ListGroup>
        </Panel>
      );
    }
  });

  ReactDOM.render(
  <AttributeList assess_id="{{id}}"/>,
  document.getElementById('content')
  );
</script>
{% endblock %}
