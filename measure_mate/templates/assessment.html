{% extends "base.html" %}
{% load staticfiles %}

{% block title %}Measure Mate{% endblock %}
{% block head %}
  <script src="{% static "components/lodash/dist/lodash.min.js" %}"></script>
{% endblock %}
{% block body %}
<div id="content" class="container-fluid"></div>
<script type="text/babel">

  var Alert = ReactBootstrap.Alert;
  var PageHeader = ReactBootstrap.PageHeader;
  var ListGroup = ReactBootstrap.ListGroup;
  var ListGroupItem = ReactBootstrap.ListGroupItem;
  var Tabs = ReactBootstrap.Tabs;
  var Tab = ReactBootstrap.Tab;
  var Panel = ReactBootstrap.Panel;
  var Input = ReactBootstrap.Input;
  var Tooltip = ReactBootstrap.Tooltip;
  var OverlayTrigger = ReactBootstrap.OverlayTrigger;
  var Pager = ReactBootstrap.Pager;
  var PageItem = ReactBootstrap.PageItem;
  var Glyphicon = ReactBootstrap.Glyphicon;

  var TemplateTable = React.createClass({
    loadAssessmentFromServer: function() {
      $.ajax({
        url: this.props.url,
        dataType: 'json',
        cache: false,
        success: function(data) {
          this.loadRatingsFromServer(data);
        }.bind(this),
        error: function(xhr, status, err) {
          console.error(this.props.url, status, err.toString());
        }.bind(this)
      });
    },
    loadRatingsFromServer: function(assess_data) {
      $.ajax({
        url: '/api/templates/' + assess_data.template.id + '/',
        dataType: 'json',
        cache: false,
        success: function(data) {
          this.setState({
            assess_id: assess_data.id,
            data: data.attributes,
            name: data.name,
            desc: data.short_desc,
            loaded: true
          });
        }.bind(this),
        error: function(xhr, status, err) {
          console.error(this.props.url, status, err.toString());
        }.bind(this)
      });
    },
    getInitialState: function() {
      return {
        data: [],
        assess_id: null,
        loaded: false
      };
    },
    componentDidMount: function() {
      this.loadAssessmentFromServer();
      // setInterval(this.loadAssessmentFromServer, this.props.pollInterval);
    },
    render: function() {
      return (
            <Loader loaded={this.state.loaded}>
              <PageHeader>
                {this.state.name} <small> {this.state.desc}</small>
              </PageHeader>
              <AttributeList assess_id={this.state.assess_id} data={this.state.data} />
            </Loader>
      );
    }
    });

  var AttributeList = React.createClass({
    getInitialState: function() {
      return {
        active_attribute: 1,
        rating_selected: false,
        measurements: null,
        next_hide: false,
        previous_hide: false
      };
    },
    componentDidMount: function(){
      this.dataSource();
    },
    dataSource: function(){
      return $.ajax({
        type: "get",
        dataType: 'json',
        url: '/api/measurements/' + '?assessment__id=' + this.props.assess_id
      }).done(function(result){
        this.setState({ measurements: result });
        this.handleTabChange(1);
      }.bind(this));
    },
    handleNext: function () {
      if (this.state.active_attribute < this.props.data.length && !this.state.next_hide) {
        var new_tab = this.state.active_attribute + 1;
        this.scrollToTop('#att-list');
        this.setState({active_attribute: new_tab});
        this.handleTabChange(new_tab);
      };
    },
    handlePrevious: function () {
      if (this.state.active_attribute !=1 && !this.state.previous_hide) {
        var new_tab = this.state.active_attribute - 1;
        this.scrollToTop('#att-list');
        this.setState({active_attribute: new_tab});
        this.handleTabChange(new_tab);
      }
    },
    handleSelect: function (key) {
      this.scrollToTop('#att-list');
      this.setState({active_attribute: key});
      this.handleTabChange(key);
    },
    handleTabChange: function (current_tab) {
      if (current_tab == 1) {
        this.setState({previous_hide: true});
      } else {
        this.setState({previous_hide: false});
      }
      if (current_tab >= this.props.data.length) {
        this.setState({next_hide: true});
      } else {
        this.setState({next_hide:false});
      }
    },
    scrollToTop: function (att_list) {
      var $target = $(att_list);

      $('html, body').stop().animate({
          'scrollTop': $target.offset().top
      }, 900, 'swing', function () {
          // window.location.hash = $target;
      });
    },
    getMeasurementForAttribute(attribute) {
      if (this.state.measurements != null) {
        for (var i=0; i < this.state.measurements.length; i++) {
          if (attribute.id == this.state.measurements[i].rating.attribute) {
            return this.state.measurements[i];
            break;
          }
        };
      } else {
        return null;
      }
    },
    render: function() {
      var attributeNodes = this.props.data.map(function (attribute, i) {
        var measurement = this.getMeasurementForAttribute(attribute);
        return (
          <Tab eventKey={i+1} key={attribute.id} id={i+1} title={<div><span className="glyphicon glyphicon-chevron-right"></span> <span>{attribute.name}</span></div>}>
            <RatingList key={attribute.id} measurement={measurement} attribute_id={attribute.id} assess_id={this.props.assess_id} name={attribute.name} desc={attribute.desc} desc_class={attribute.desc_class} data={attribute.ratings}/>
          </Tab>
        );
      }.bind(this));
      return (
        <div id="att-list">
          <Tabs position="right" activeKey={this.state.active_attribute} onSelect={this.handleSelect} tabWidth={3}>
            {attributeNodes}
            <Pager>
              <PageItem disabled={this.state.previous_hide} onClick={this.handlePrevious}>&larr; Previous</PageItem>
              {' '}
              <PageItem disabled={this.state.next_hide} onClick={this.handleNext}>Next &rarr;</PageItem>
            </Pager>
          </Tabs>
        </div>
      );
    }
  });

  var ObserveInput = React.createClass({
      getInitialState: function () {
          return {
              observations: null
          };
      },

      componentWillReceiveProps: function(newProps) {
        if (this.state.observations == null) {
          this.setState(
            {
              observations: newProps.observations
            });
        }
      },

      componentWillMount: function() {
        //  this.handleObserveDebounced = _.debounce(function () {
        //    console.log("Inside debounce: " + this.state.observations);
        //    this.props.handleObserve.apply(this, [this.state.observations]);
        //  }, 5000);
      },

      onChange: function (event) {
        var new_observations = event.target.value;
        this.setState({observations: new_observations});
        this.props.handleSyncState(false);
        this.props.handleObserve(event.target.value);
        // this.handleObserveDebounced();
      },

      render: function () {
        return (
          <Input type="textarea" rows="3" label="Observations" placeholder="Some notes on why a particular rating was selected."
                 ref="observeInput"
                 value={this.state.observations}
                 onChange={this.onChange} Input/>
        );
      }
  });

  var RatingList = React.createClass({
    componentWillMount() {
      this.syncMeasurement = _.debounce(this.syncMeasurement, 2000);
    },
    getInitialState: function() {
      if (this.props.measurement != null) {
        return {
          measurement_id: this.props.measurement.id,
          selected_rating: this.props.measurement.rating.id,
          observations: this.props.measurement.observations,
          observation_synced: true,
          saved_rating: true
        };
      } else {
        return {
          measurement_id: null,
          selected_rating: null,
          observations: "",
          observation_synced: true,
          saved_rating: true
        };
      }
    },
    componentWillReceiveProps: function(newProps) {
      if (newProps.measurement && newProps.measurement.id != this.measurement_id) {
        this.setState(
          {
            measurement_id: newProps.measurement.id,
            selected_rating: newProps.measurement.rating.id,
            observations: newProps.measurement.observations
          });
      }
    },
    syncMeasurement: function(postData) {
      var create_new_measure = ((this.state.measurement_id == null) ? true : false);
      console.log('Should a new measurement be created? ' + create_new_measure);
      $.ajax({
        type: ((create_new_measure) ? "POST" : "PUT"),
        contentType: "application/json; charset=utf-8",
        url: ((create_new_measure) ? "/api/measurements/" : ("/api/measurements/" + this.state.measurement_id + '/')),
        data: JSON.stringify(postData),
        dataType: 'json',
        success: this.handleSubmitSuccess,
        error: this.handleSubmitFailure,
      });
    },
    handleSyncState: function (synced) {
      this.setState({observation_synced: synced});
    },
    handleObserve: function (text) {
      this.setState(
        {
          observations: text,
        });
      var postData = {
        id: this.state.measurement_id,
        assessment: this.props.assess_id,
        rating: this.state.selected_rating,
        observations: text
      };
      // this.syncMeasurement(postData);
    },
    handleClick: function(data) {
      var create_new_measure = ((this.state.measurement_id == null) ? true : false);
      console.log('Should a new measurement be created? ' + create_new_measure);
      var postContent = data.postContent;
      var postData = {
        id: this.state.measurement_id,
        assessment: this.props.assess_id,
        rating: data,
        observations: this.state.observations
      };

      this.setState(
        {
          selected_rating: data,
          saved_rating: false
        });
      this.syncMeasurement(postData);
    },
    handleSubmitSuccess: function(data) {
      this.setState({
        measurement_id: data.id,
        observation_synced: true,
        saved_rating: true
      });
    },

    handleSubmitFailure: function(xhr, ajaxOptions, thrownError) {
        console.error("There was a failure");
    },

    render: function() {
      var ratingNodes = this.props.data.map(function (rating) {
          var active = (this.state.selected_rating == rating.id)
          var desc_class = "rating-" + rating.name + (rating.desc_class ? " " + rating.desc_class : "")
          return (
            <ListGroupItem active={active} onClick={this.handleClick.bind(this, rating.id)} id={rating.id} key={rating.id} header={rating.name} className={desc_class}>
              {rating.desc}
            </ListGroupItem>
          );
      }.bind(this));
      var syncStatus = function () {
        if (this.state.observation_synced == true) {
          return (<p><Glyphicon glyph="glyphicon glyphicon-saved" /> Saved</p>);
        } else {
          return (<p><Glyphicon glyph="glyphicon glyphicon-info-sign" /> This comment will be saved once a rating below is selected</p>);
        }
      }.bind(this);
      var desc_class = this.props.desc_class || ""
      return (
        <Panel header={this.props.name} bsStyle="primary">
          <p className={desc_class}>{this.props.desc}</p>
          <ObserveInput observations={this.state.observations} handleSyncState={this.handleSyncState}
                     handleObserve={this.handleObserve} syncMeasurement={this.syncMeasurement}/>
          <Loader loaded={this.state.saved_rating}>
          </Loader>
          {syncStatus()}
          <ListGroup fill>
            {ratingNodes}
          </ListGroup>
        </Panel>
      );
    }
  });

  ReactDOM.render(
  <TemplateTable url="/api/assessments/{{id}}/" pollInterval={20000}/>,
  document.getElementById('content')
  );
</script>
{% endblock %}
