{% extends "base.html" %}
{% load staticfiles %}

{% block title %}Measure Mate{% endblock %}
{% block head %}
  <script src="{% static "components/chartist/dist/chartist.min.js" %}"></script>

  <link rel="stylesheet" href="{% static "components/chartist/dist/chartist.min.css" %}">
  <style>
        .ct-series-a .ct-bar {
          stroke: #cccccc;
          stroke-width: 30px;
        }
        .ct-series-b .ct-bar {
          stroke: blue;
          stroke-width: 20px;
        }
        .ct-chart-bar .ct-label {
          color: black;
        }
  </style>
{% endblock %}
{% block body %}
<div id="content" class="container"></div>
<script type="text/babel">
var PageHeader = ReactBootstrap.PageHeader;

var AssessmentByAttributeGraph = React.createClass({
  propTypes: {
    url: React.PropTypes.string.isRequired,
  },
  getInitialState: function() {
    return {
      assessment_detail: null,
      template_detail: null,
      measurements: null,
      loaded: false
    };
  },
  componentDidMount: function() {
    this.loadAssessmentFromServer();
  },
  loadAssessmentFromServer: function() {
    $.ajax({
      url: this.props.url,
      dataType: 'json',
      cache: false,
      success: function(data) {
        this.setState({
          assessment_detail: data
        })
        this.loadRatingsFromServer(data);
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  loadRatingsFromServer: function(assess_data) {
    $.ajax({
      url: '/api/templates/' + assess_data.template.id + '/',
      dataType: 'json',
      cache: false,
      success: function(data) {
        this.setState({
          template_detail: data
        });
        this.loadMeasurementsFromServer(assess_data.id);
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  loadMeasurementsFromServer: function(assess_id) {
    $.ajax({
      url: '/api/measurements/' + '?assessment__id=' + assess_id,
      dataType: 'json',
      cache: false,
      success: function(data) {
        this.setState({
          measurements: data,
          loaded: true
        });
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  getMeasurementForAttribute(attribute) {
    if (this.state.measurements != null) {
      for (var i=0; i < this.state.measurements.length; i++) {
        if (attribute.id == this.state.measurements[i].rating.attribute) {
          return this.state.measurements[i];
          break;
        }
      };
    } else {
      return null;
    }
  },
  render: function() {
    var labels = [];
    var target_series = {
      className: 'ct-series-a',
      name: 'Target Rating',
      data: [],
    }
    var rating_series = {
      className: 'ct-series-b',
      name: 'Current Rating',
      data: [],
    }
    var max_rank = null;
    var min_rank = null;
    var ratings_by_rank = {};
    if (this.state.measurements != null) {
      (this.state.template_detail.attributes.map(function (attribute, i) {
        var measurement = this.getMeasurementForAttribute(attribute);
        labels.push(attribute.name);
        (measurement && measurement.rating) ? rating_series.data.push(measurement.rating.rank) : rating_series.data.push(0);
        (measurement && measurement.target_rating) ? target_series.data.push(measurement.target_rating.rank) : target_series.data.push(0);
        if (max_rank == null) {
          for (var i=0; i < attribute.ratings.length; i++) {
            var rating = attribute.ratings[i];
            ratings_by_rank[rating.rank] = rating
            if (max_rank == null || max_rank < rating.rank) {
              max_rank = rating.rank
            }
            if (min_rank == null || min_rank > rating.rank) {
              min_rank = rating.rank
            }
          }
        }
      }.bind(this)));
    }
    var data = {"labels": labels, "series": [target_series, rating_series]};
    var listeners = {
      draw: function(context) {
        if (context.type === 'bar' && context.series.name == "Current Rating") {
          if (Chartist.getMultiValue(context.value) < 0) {
            context.element.attr({
              style: 'stroke: red;'
            });
          }
        }
      }};
    // We are setting a few options for our chart and override the defaults
    var options = {
      // Stack bars...
      stackBars: true,
      // ... but make them overlap, not accumulate
      stackMode: 'overlap',
      // X-Axis specific configuration
      axisX: {
        showGrid: true,
        // and show the label
        showLabel: true,
        offset: 100,
      },
      // Y-Axis specific configuration
      axisY: {
        high: max_rank,
        low: min_rank,
        onlyInteger: true,

        labelInterpolationFnc: function(value) {
          if (ratings_by_rank[value]) {
            return ratings_by_rank[value].name
          }
          else if (value == 0) {
            return "N/A"
          }
          return value;
        }
      },
      width: 600,
      height: 400
    };
    return (
          <Loader loaded={this.state.loaded}>
            <ChartistGraph data={data} options={options} listener={listeners} type="Bar" className=""/>
          </Loader>
    );
  }
  });


var ChartistGraph = React.createClass({
  displayName: 'ChartistGraph',

  propTypes: {
    type: React.PropTypes.string.isRequired,
    data: React.PropTypes.object.isRequired,
    className: React.PropTypes.string,
    options: React.PropTypes.object,
    responsiveOptions: React.PropTypes.array
  },
  componentWillReceiveProps: function (newProps) {
    this.updateChart(newProps);
  },

  componentWillUnmount: function () {
    if (this.chartist) {
      try {
        this.chartist.detach();
      } catch (err) {
        throw new Error('Internal chartist error', err);
      }
    }
  },

  componentDidMount: function () {
    this.updateChart(this.props);
  },

  updateChart: function (config) {
    let Chartist = window.Chartist;

    let { type, data } = config;
    let options = config.options || {};
    let responsiveOptions = config.responsiveOptions || [];
    let event;

    if (this.chartist) {
      this.chartist.update(data, options, responsiveOptions);
    } else {
      this.chartist = new Chartist[type](ReactDOM.findDOMNode(this), data, options, responsiveOptions);

      if (config.listener) {
        for (event in config.listener) {
          if (config.listener.hasOwnProperty(event)) {
            this.chartist.on(event, config.listener[event]);
          }
        }
      }

    }
    return this.chartist;
  },

  render: function() {
    const className = this.props.className ? ' ' + this.props.className : ''
    const style = this.props.style ? this.props.style : {};
    return (<div className={'ct-chart' + className} style={style} />)
  }
});

var MyComponent = React.createClass({
  render: function() {
    return <LineChart data={chartData} options={chartOptions} width="600" height="250"/>
  }
});

var AssessmentReport = React.createClass({
  render: function() {
    return (
      <div>
        <PageHeader>
          Assessment Summary <small> Current and Target</small>
        </PageHeader>
        <AssessmentByAttributeGraph url="/api/assessments/{{id}}/"/>
      </div>
    )
  }
});

  ReactDOM.render(
  <AssessmentReport/>,
  document.getElementById('content')
  );
</script>
{% endblock %}
